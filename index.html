<!DOCTYPE html>
<html>
<head>
    <title>Land Use Map - Madrid</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <!-- Add Proj4Leaflet for coordinate transformation -->
    <script src="https://unpkg.com/proj4@2.8.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #map { 
            height: 100vh; 
            width: 100vw; 
        }
        .legend { 
            background: white; 
            padding: 15px; 
            border: 2px solid grey; 
            border-radius: 8px;
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            max-height: 50vh;
            overflow-y: auto; 
            z-index: 1000; 
            font-size: 13px;
            min-width: 220px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .legend-item { 
            margin: 3px 0; 
            display: flex; 
            align-items: center; 
        }
        .legend-color { 
            width: 16px; 
            height: 16px; 
            margin-right: 10px; 
            border: 1px solid #ccc; 
            flex-shrink: 0;
        }
        .legend-text { 
            word-wrap: break-word; 
            line-height: 1.3;
        }
        .loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 14px;
            display: none;
        }
        .chunk-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 12px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="legend">
        <b>HILUCS Categories</b>
        <div id="legend-items"></div>
    </div>
    <div class="loading-indicator" id="loading">Loading chunks...</div>
    <div class="chunk-info" id="chunk-info">Loaded: 0/0 chunks</div>

    <script>
        const colorMap = {
            "AbandonedAreas": "#1f77b4",
            "Agriculture": "#aec7e8",
            "AquacultureAndFishing": "#ff7f0e",
            "CommercialServices": "#ffbb78",
            "CommunityServices": "#2ca02c",
            "CulturalEntertainmentAndRecreationalServices": "#98df8a",
            "Forestry": "#d62728",
            "LandAreasNotInOtherEconomicUse": "#ff9896",
            "MiningAndQuarrying": "#9467bd",
            "NotKnownUse": "#c5b0d5",
            "ResidentialUse": "#8c564b",
            "SecondaryProduction": "#c49c94",
            "TransitionalAreas": "#e377c2",
            "TransportNetworks": "#f7b6d2",
            "Utilities": "#7f7f7f",
            "WaterAreasNotInOtherEconomicUse": "#c7c7c7"
        };

        // Define coordinate transformation (UTM Zone 30N to WGS84)
        proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // Initialize map centered on Madrid
        const MADRID_CENTER = [40.4168, -3.7038];
        const map = L.map('map').setView(MADRID_CENTER, 10);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);

        // Chunk management
        const loadedChunks = new Set();
        const chunkLayers = new Map();
        let isLoading = false;
        let loadQueue = [];

        // Generate all chunk URLs
        const chunkUrls = [];
        for (let i = 0; i < 90; i++) {
            chunkUrls.push(`https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_${i}.geojson`);
        }

        // Transform coordinates function
        function transformCoordinates(coordinates) {
            if (coordinates[0] instanceof Array) {
                return coordinates.map(transformCoordinates);
            } else {
                const [x, y] = coordinates;
                const [lng, lat] = proj4("EPSG:25830", "EPSG:4326", [x, y]);
                return [lng, lat];
            }
        }

        // Style function
        function getStyle(feature) {
            const category = feature.properties.HILUCS_DESC;
            const color = colorMap[category] || '#999999';
            return {
                fillColor: color,
                color: 'black',
                weight: 0.5,
                fillOpacity: 0.7,
                opacity: 1
            };
        }

        // Update UI indicators
        function updateChunkInfo() {
            document.getElementById('chunk-info').innerHTML = 
                `Loaded: ${loadedChunks.size}/${chunkUrls.length} chunks`;
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Enhanced load chunk function with detailed logging
        async function loadChunk(url, index) {
            if (loadedChunks.has(index)) {
                console.log(`Chunk ${index} already loaded, skipping`);
                return;
            }

            console.log(`Attempting to load chunk ${index + 1}/${chunkUrls.length} from: ${url}`);
            
            try {
                console.log(`Fetching: ${url}`);
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log(`Response received for chunk ${index}, status: ${response.status}`);
                const data = await response.json();
                console.log(`Data parsed for chunk ${index}, features: ${data.features?.length || 0}`);
                
                if (data.features && data.features.length > 0) {
                    // Transform coordinates for each feature
                    data.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.coordinates) {
                            if (feature.geometry.type === 'Polygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            }
                        }
                    });

                    const geoJsonLayer = L.geoJSON(data, {
                        style: getStyle,
                        onEachFeature: function(feature, layer) {
                            const category = feature.properties.HILUCS_DESC || 'Unknown';
                            layer.bindTooltip(`<b>HILUCS:</b> ${category}`, {
                                sticky: true,
                                direction: 'top'
                            });
                        }
                    });

                    geoJsonLayer.addTo(map);
                    chunkLayers.set(index, geoJsonLayer);
                    loadedChunks.add(index);
                    
                    console.log('Chunk ${index + 1} loaded successfully: ${data.features.length} features`);
                } else {
                    console.log(`Chunk ${index + 1} has no features`);
                }
            } catch (error) {
                console.error(`Error loading chunk ${index + 1}:`, error);
                console.error(`URL: ${url}`);
                console.error(`Error details:`, error.message);
            }
            
            updateChunkInfo();
        }

        // Enhanced batch loading with better error handling
        async function loadChunksBatch(chunkIndices, batchSize = 3) {
            if (isLoading) {
                console.log("Already loading, skipping batch");
                return;
            }
            
            isLoading = true;
            showLoading();
            
            console.log(`Loading batch of ${chunkIndices.length} chunks`);
            
            // Process in batches to avoid overwhelming the browser
            for (let i = 0; i < chunkIndices.length; i += batchSize) {
                const batch = chunkIndices.slice(i, i + batchSize);
                console.log(`Processing batch ${Math.floor(i/batchSize) + 1}, indices:`, batch);
                
                const promises = batch
                    .filter(index => !loadedChunks.has(index))
                    .map(index => {
                        console.log(`Creating promise for chunk ${index}`);
                        return loadChunk(chunkUrls[index], index);
                    });
                
                if (promises.length > 0) {
                    console.log(`Executing ${promises.length} promises`);
                    await Promise.allSettled(promises); // Use allSettled instead of all
                }
                
                // Small delay between batches to keep UI responsive
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            isLoading = false;
            hideLoading();
            console.log(`Batch loading complete. Total loaded: ${loadedChunks.size}`);
        }

        // Test chunk URLs for accessibility
        async function testChunkUrls() {
            console.log("Testing first few chunk URLs...");
            
            for (let i = 0; i < Math.min(3, chunkUrls.length); i++) {
                const url = chunkUrls[i];
                try {
                    console.log(`Testing URL: ${url}`);
                    const response = await fetch(url, { method: 'HEAD' });
                    console.log(`URL ${i}: ${response.status} ${response.statusText}`);
                } catch (error) {
                    console.error(`URL ${i} failed:`, error.message);
                }
            }
        }

        // Manual URL test function
        function manualUrlTest() {
            const testUrl = "https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_0.geojson";
            console.log("Manual URL test:", testUrl);
            
            fetch(testUrl)
                .then(response => {
                    console.log("Manual test response:", response.status, response.statusText);
                    return response.text();
                })
                .then(text => {
                    console.log("Manual test response text length:", text.length);
                    console.log("First 200 characters:", text.substring(0, 200));
                    try {
                        JSON.parse(text);
                        console.log("JSON is valid");
                    } catch (e) {
                        console.error("JSON is invalid:", e.message);
                    }
                })
                .catch(error => {
                    console.error("Manual test error:", error);
                });
        }

        // Determine which chunks to load based on map view and zoom
        function getRelevantChunks() {
            const zoom = map.getZoom();
            const bounds = map.getBounds();
            
            // Load more chunks at higher zoom levels
            let chunksToLoad;
            if (zoom >= 12) {
                // High zoom: load chunks that intersect current view
                chunksToLoad = getChunksInBounds(bounds);
            } else if (zoom >= 10) {
                // Medium zoom: load subset of chunks
                chunksToLoad = Array.from({length: 30}, (_, i) => i);
            } else {
                // Low zoom: load only a few representative chunks
                chunksToLoad = Array.from({length: 10}, (_, i) => i * 9);
            }
            
            return chunksToLoad;
        }

        // Simplified bounds checking
        function getChunksInBounds(bounds) {
            // Since we don't know exact chunk bounds, load progressively
            const totalChunks = chunkUrls.length;
            const maxChunks = Math.min(40, totalChunks);
            return Array.from({length: maxChunks}, (_, i) => i);
        }

        // Load initial chunks
        function loadInitialChunks() {
            const initialChunks = getRelevantChunks();
            console.log("Loading initial chunks:", initialChunks);
            loadChunksBatch(initialChunks);
        }

        // Event listeners for dynamic loading
        map.on('zoomend', function() {
            const newChunks = getRelevantChunks();
            const unloadedChunks = newChunks.filter(i => !loadedChunks.has(i));
            
            if (unloadedChunks.length > 0) {
                console.log("Zoom changed, loading new chunks:", unloadedChunks);
                loadChunksBatch(unloadedChunks);
            }
        });

        map.on('moveend', function() {
            const zoom = map.getZoom();
            if (zoom >= 11) { // Only load on move at higher zoom levels
                const newChunks = getRelevantChunks();
                const unloadedChunks = newChunks.filter(i => !loadedChunks.has(i));
                
                if (unloadedChunks.length > 0 && unloadedChunks.length <= 10) {
                    console.log("Map moved, loading new chunks:", unloadedChunks);
                    loadChunksBatch(unloadedChunks, 2); // Smaller batches for move events
                }
            }
        });

        // Generate legend
        function generateLegend() {
            const legendItems = document.getElementById('legend-items');
            Object.entries(colorMap).forEach(([category, color]) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${color};"></div>
                    <div class="legend-text">${category}</div>
                `;
                legendItems.appendChild(item);
            });
        }

        // Initialize everything
        console.log('Map initialized. Dynamic chunk loading enabled.');
        console.log(`Total chunks available: ${chunkUrls.length}`);
        
        generateLegend();
        updateChunkInfo();

        // Call manual URL test immediately
        manualUrlTest();

        // Test URLs first, then load chunks
        setTimeout(async () => {
            await testChunkUrls();
            
            // Try loading just the first chunk to test
            console.log("Testing single chunk load...");
            await loadChunk(chunkUrls[0], 0);
            
            // If successful, load more
            if (loadedChunks.size > 0) {
                console.log("Single chunk test successful, loading more...");
                loadInitialChunks();
            } else {
                console.error("Single chunk test failed, check URLs and CORS policy");
                console.log("Attempting to load initial chunks anyway...");
                loadInitialChunks();
            }
        }, 1000);
    </script>
</body>
</html>
