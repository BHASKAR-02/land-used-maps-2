<!DOCTYPE html>
<html>
<head>
    <title>Land Use Map - Madrid</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/proj4@2.8.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #map { 
            height: 100vh; 
            width: 100vw; 
        }
        .legend { 
            background: white; 
            padding: 15px; 
            border: 2px solid grey; 
            border-radius: 8px;
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            max-height: 50vh;
            overflow-y: auto; 
            z-index: 1000; 
            font-size: 13px;
            min-width: 220px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .legend-item { 
            margin: 3px 0; 
            display: flex; 
            align-items: center; 
        }
        .legend-color { 
            width: 16px; 
            height: 16px; 
            margin-right: 10px; 
            border: 1px solid #ccc; 
            flex-shrink: 0;
        }
        .legend-text { 
            word-wrap: break-word; 
            line-height: 1.3;
        }
        .loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 14px;
            display: none;
        }
        .chunk-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 12px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="legend">
        <b>HILUCS Categories</b>
        <div id="legend-items"></div>
    </div>
    <div class="loading-indicator" id="loading">Loading chunks...</div>
    <div class="chunk-info" id="chunk-info">Loaded: 0/0 chunks</div>

    <script>
        // Color mapping for different land use categories
        const colorMap = {
            "AbandonedAreas": "#1f77b4",
            "Agriculture": "#aec7e8",
            "AquacultureAndFishing": "#ff7f0e",
            "CommercialServices": "#ffbb78",
            "CommunityServices": "#2ca02c",
            "CulturalEntertainmentAndRecreationalServices": "#98df8a",
            "Forestry": "#d62728",
            "LandAreasNotInOtherEconomicUse": "#ff9896",
            "MiningAndQuarrying": "#9467bd",
            "NotKnownUse": "#c5b0d5",
            "ResidentialUse": "#8c564b",
            "SecondaryProduction": "#c49c94",
            "TransitionalAreas": "#e377c2",
            "TransportNetworks": "#f7b6d2",
            "Utilities": "#7f7f7f",
            "WaterAreasNotInOtherEconomicUse": "#c7c7c7"
        };

        // Define coordinate transformation (UTM Zone 30N to WGS84)
        proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // Initialize map centered on Madrid
        const MADRID_CENTER = [40.4168, -3.7038];
        const map = L.map('map').setView(MADRID_CENTER, 10);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);

        // Chunk management variables
        const loadedChunks = new Set();
        const chunkLayers = new Map();
        let isLoading = false;

        // Generate all chunk URLs
        const chunkUrls = [];
        for (let i = 0; i < 90; i++) {
            chunkUrls.push("https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_" + i + ".geojson");
        }

        // Transform coordinates function
        function transformCoordinates(coordinates) {
            if (coordinates[0] instanceof Array) {
                return coordinates.map(transformCoordinates);
            } else {
                const x = coordinates[0];
                const y = coordinates[1];
                const transformed = proj4("EPSG:25830", "EPSG:4326", [x, y]);
                return [transformed[0], transformed[1]];
            }
        }

        // Style function for features
        function getStyle(feature) {
            const category = feature.properties.HILUCS_DESC;
            const color = colorMap[category] || "#999999";
            return {
                fillColor: color,
                color: "black",
                weight: 0.5,
                fillOpacity: 0.7,
                opacity: 1
            };
        }

        // Update UI indicators
        function updateChunkInfo() {
            const element = document.getElementById('chunk-info');
            element.innerHTML = "Loaded: " + loadedChunks.size + "/" + chunkUrls.length + " chunks";
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Load a single chunk with enhanced error handling
        async function loadChunk(url, index) {
            if (loadedChunks.has(index)) {
                console.log("Chunk " + index + " already loaded, skipping");
                return;
            }

            console.log("Attempting to load chunk " + (index + 1) + "/" + chunkUrls.length + " from: " + url);
            
            try {
                console.log("Fetching: " + url);
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + ": " + response.statusText);
                }
                
                console.log("Response received for chunk " + index + ", status: " + response.status);
                const data = await response.json();
                console.log("Data parsed for chunk " + index + ", features: " + (data.features ? data.features.length : 0));
                
                if (data.features && data.features.length > 0) {
                    // Transform coordinates for each feature
                    data.features.forEach(function(feature) {
                        if (feature.geometry && feature.geometry.coordinates) {
                            if (feature.geometry.type === 'Polygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            }
                        }
                    });

                    const geoJsonLayer = L.geoJSON(data, {
                        style: getStyle,
                        onEachFeature: function(feature, layer) {
                            const category = feature.properties.HILUCS_DESC || 'Unknown';
                            layer.bindTooltip("<b>HILUCS:</b> " + category, {
                                sticky: true,
                                direction: 'top'
                            });
                        }
                    });

                    geoJsonLayer.addTo(map);
                    chunkLayers.set(index, geoJsonLayer);
                    loadedChunks.add(index);
                    
                    console.log("✅ Chunk " + (index + 1) + " loaded successfully: " + data.features.length + " features");
                } else {
                    console.log("⚠️ Chunk " + (index + 1) + " has no features");
                }
            } catch (error) {
                console.error("❌ Error loading chunk " + (index + 1) + ":", error);
                console.error("URL: " + url);
                console.error("Error details:", error.message);
            }
            
            updateChunkInfo();
        }

        // Load chunks in batches
        async function loadChunksBatch(chunkIndices, batchSize) {
            if (typeof batchSize === 'undefined') {
                batchSize = 3;
            }
            
            if (isLoading) {
                console.log("Already loading, skipping batch");
                return;
            }
            
            isLoading = true;
            showLoading();
            
            console.log("Loading batch of " + chunkIndices.length + " chunks");
            
            // Process in batches
            for (let i = 0; i < chunkIndices.length; i += batchSize) {
                const batch = chunkIndices.slice(i, i + batchSize);
                console.log("Processing batch " + (Math.floor(i/batchSize) + 1) + ", indices:", batch);
                
                const promises = [];
                for (let j = 0; j < batch.length; j++) {
                    const index = batch[j];
                    if (!loadedChunks.has(index)) {
                        console.log("Creating promise for chunk " + index);
                        promises.push(loadChunk(chunkUrls[index], index));
                    }
                }
                
                if (promises.length > 0) {
                    console.log("Executing " + promises.length + " promises");
                    await Promise.allSettled(promises);
                }
                
                // Small delay between batches
                await new Promise(function(resolve) {
                    setTimeout(resolve, 200);
                });
            }
            
            isLoading = false;
            hideLoading();
            console.log("Batch loading complete. Total loaded: " + loadedChunks.size);
        }

        // Test if chunk URLs are accessible
        async function testChunkUrls() {
            console.log("Testing first few chunk URLs...");
            
            const testCount = Math.min(3, chunkUrls.length);
            for (let i = 0; i < testCount; i++) {
                const url = chunkUrls[i];
                try {
                    console.log("Testing URL: " + url);
                    const response = await fetch(url, { method: 'HEAD' });
                    console.log("URL " + i + ": " + response.status + " " + response.statusText);
                } catch (error) {
                    console.error("URL " + i + " failed:", error.message);
                }
            }
        }

        // Manual URL test
        function manualUrlTest() {
            const testUrl = "https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_0.geojson";
            console.log("Manual URL test:", testUrl);
            
            fetch(testUrl)
                .then(function(response) {
                    console.log("Manual test response:", response.status, response.statusText);
                    return response.text();
                })
                .then(function(text) {
                    console.log("Manual test response text length:", text.length);
                    console.log("First 200 characters:", text.substring(0, 200));
                    try {
                        JSON.parse(text);
                        console.log("✅ JSON is valid");
                    } catch (e) {
                        console.error("❌ JSON is invalid:", e.message);
                    }
                })
                .catch(function(error) {
                    console.error("Manual test error:", error);
                });
        }

        // Get relevant chunks based on zoom level
        function getRelevantChunks() {
            const zoom = map.getZoom();
            
            let chunksToLoad;
            if (zoom >= 12) {
                const totalChunks = Math.min(40, chunkUrls.length);
                chunksToLoad = [];
                for (let i = 0; i < totalChunks; i++) {
                    chunksToLoad.push(i);
                }
            } else if (zoom >= 10) {
                chunksToLoad = [];
                for (let i = 0; i < 30; i++) {
                    chunksToLoad.push(i);
                }
            } else {
                chunksToLoad = [];
                for (let i = 0; i < 10; i++) {
                    chunksToLoad.push(i * 9);
                }
            }
            
            return chunksToLoad;
        }

        // Load initial chunks
        function loadInitialChunks() {
            const initialChunks = getRelevantChunks();
            console.log("Loading initial chunks:", initialChunks);
            loadChunksBatch(initialChunks);
        }

        // Map event listeners
        map.on('zoomend', function() {
            const newChunks = getRelevantChunks();
            const unloadedChunks = newChunks.filter(function(i) {
                return !loadedChunks.has(i);
            });
            
            if (unloadedChunks.length > 0) {
                console.log("Zoom changed, loading new chunks:", unloadedChunks);
                loadChunksBatch(unloadedChunks);
            }
        });

        map.on('moveend', function() {
            const zoom = map.getZoom();
            if (zoom >= 11) {
                const newChunks = getRelevantChunks();
                const unloadedChunks = newChunks.filter(function(i) {
                    return !loadedChunks.has(i);
                });
                
                if (unloadedChunks.length > 0 && unloadedChunks.length <= 10) {
                    console.log("Map moved, loading new chunks:", unloadedChunks);
                    loadChunksBatch(unloadedChunks, 2);
                }
            }
        });

        // Generate legend
        function generateLegend() {
            const legendItems = document.getElementById('legend-items');
            const entries = Object.entries(colorMap);
            
            for (let i = 0; i < entries.length; i++) {
                const category = entries[i][0];
                const color = entries[i][1];
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = color;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'legend-text';
                textDiv.textContent = category;
                
                item.appendChild(colorDiv);
                item.appendChild(textDiv);
                legendItems.appendChild(item);
            }
        }

        // Initialize everything
        console.log('Map initialized. Dynamic chunk loading enabled.');
        console.log('Total chunks available: ' + chunkUrls.length);
        
        generateLegend();
        updateChunkInfo();

        // Start the loading process
        manualUrlTest();

        setTimeout(function() {
            testChunkUrls().then(function() {
                console.log("Testing single chunk load...");
                return loadChunk(chunkUrls[0], 0);
            }).then(function() {
                if (loadedChunks.size > 0) {
                    console.log("Single chunk test successful, loading more...");
                    loadInitialChunks();
                } else {
                    console.error("Single chunk test failed, check URLs and CORS policy");
                    console.log("Attempting to load initial chunks anyway...");
                    loadInitialChunks();
                }
            }).catch(function(error) {
                console.error("Error in initialization:", error);
                loadInitialChunks();
            });
        }, 1000);
    </script>
</body>
</html>
