<!DOCTYPE html>
<html>
<head>
    <title>Land Use Map - Madrid</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/proj4@2.8.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #map { 
            height: 100vh; 
            width: 100vw; 
        }
        .legend { 
            background: white; 
            padding: 15px; 
            border: 2px solid grey; 
            border-radius: 8px;
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            max-height: 60vh;
            overflow-y: auto; 
            z-index: 1000; 
            font-size: 13px;
            min-width: 280px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .legend-header {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ccc;
            padding-bottom: 8px;
        }
        .legend-controls {
            display: flex;
            gap: 8px;
        }
        .legend-btn {
            background: #f0f0f0;
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.2s;
        }
        .legend-btn:hover {
            background: #e0e0e0;
        }
        .legend-item { 
            margin: 3px 0; 
            display: flex; 
            align-items: center;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            transition: background-color 0.2s;
            user-select: none;
        }
        .legend-item:hover {
            background-color: #f5f5f5;
        }
        .legend-item.disabled {
            opacity: 0.5;
        }
        .legend-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
            pointer-events: none; /* Prevent direct checkbox interaction */
        }
        .legend-color { 
            width: 16px; 
            height: 16px; 
            margin-right: 10px; 
            border: 1px solid #ccc; 
            flex-shrink: 0;
        }
        .legend-text { 
            word-wrap: break-word; 
            line-height: 1.3;
            flex-grow: 1;
        }
        .loading-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 14px;
            display: none;
        }
        .chunk-info {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 5px;
            z-index: 1001;
            font-size: 12px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="legend">
        <div class="legend-header">
            <b>HILUCS Categories</b>
            <div class="legend-controls">
                <div class="legend-btn" onclick="toggleAllCategories(true)">Show All</div>
                <div class="legend-btn" onclick="toggleAllCategories(false)">Hide All</div>
            </div>
        </div>
        <div id="legend-items"></div>
    </div>
    <div class="loading-indicator" id="loading">Loading chunks...</div>
    <div class="chunk-info" id="chunk-info">Loaded: 0/0 chunks</div>

    <script>
        // Color mapping for different land use categories
        const colorMap = {
            "AbandonedAreas": "#1f77b4",
            "Agriculture": "#aec7e8",
            "AquacultureAndFishing": "#ff7f0e",
            "CommercialServices": "#ffbb78",
            "CommunityServices": "#2ca02c",
            "CulturalEntertainmentAndRecreationalServices": "#98df8a",
            "Forestry": "#d62728",
            "LandAreasNotInOtherEconomicUse": "#ff9896",
            "MiningAndQuarrying": "#9467bd",
            "NotKnownUse": "#c5b0d5",
            "ResidentialUse": "#8c564b",
            "SecondaryProduction": "#c49c94",
            "TransitionalAreas": "#e377c2",
            "TransportNetworks": "#f7b6d2",
            "Utilities": "#7f7f7f",
            "WaterAreasNotInOtherEconomicUse": "#c7c7c7"
        };

        // Category visibility state
        const categoryVisibility = {};
        // Initialize all categories as visible
        Object.keys(colorMap).forEach(function(category) {
            categoryVisibility[category] = true;
        });

        // Define coordinate transformation (UTM Zone 30N to WGS84)
        proj4.defs("EPSG:25830", "+proj=utm +zone=30 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

        // Initialize map centered on Madrid
        const MADRID_CENTER = [40.4168, -3.7038];
        const map = L.map('map').setView(MADRID_CENTER, 10);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(map);

        // Chunk management variables
        const loadedChunks = new Set();
        const chunkLayers = new Map();
        let isLoading = false;

        // Generate all chunk URLs
        const chunkUrls = [];
        for (let i = 0; i < 90; i++) {
            chunkUrls.push("https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_" + i + ".geojson");
        }

        // Transform coordinates function
        function transformCoordinates(coordinates) {
            if (coordinates[0] instanceof Array) {
                return coordinates.map(transformCoordinates);
            } else {
                const x = coordinates[0];
                const y = coordinates[1];
                const transformed = proj4("EPSG:25830", "EPSG:4326", [x, y]);
                return [transformed[0], transformed[1]];
            }
        }

        // Style function for features
        function getStyle(feature) {
            const category = feature.properties.HILUCS_DESC;
            const color = colorMap[category] || "#999999";
            
            // Check if category should be visible
            const isVisible = categoryVisibility[category] !== false;
            
            return {
                fillColor: color,
                color: "black",
                weight: 0.5,
                fillOpacity: isVisible ? 0.7 : 0,
                opacity: isVisible ? 1 : 0
            };
        }

        // Update UI indicators
        function updateChunkInfo() {
            const element = document.getElementById('chunk-info');
            element.innerHTML = "Loaded: " + loadedChunks.size + "/" + chunkUrls.length + " chunks";
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Toggle category visibility - Fixed click handler
        function toggleCategory(category, event) {
            // Prevent event bubbling if called from within the legend item
            if (event) {
                event.stopPropagation();
            }
            
            categoryVisibility[category] = !categoryVisibility[category];
            updateLayerStyles();
            updateLegendCheckboxes();
        }

        // Toggle all categories
        function toggleAllCategories(visible) {
            Object.keys(colorMap).forEach(function(category) {
                categoryVisibility[category] = visible;
            });
            updateLayerStyles();
            updateLegendCheckboxes();
        }

        // Update layer styles based on visibility
        function updateLayerStyles() {
            chunkLayers.forEach(function(layer, index) {
                layer.eachLayer(function(featureLayer) {
                    const newStyle = getStyle(featureLayer.feature);
                    featureLayer.setStyle(newStyle);
                });
            });
        }

        // Update legend checkboxes
        function updateLegendCheckboxes() {
            Object.keys(colorMap).forEach(function(category) {
                const checkbox = document.getElementById('checkbox-' + category);
                const legendItem = document.getElementById('item-' + category);
                if (checkbox && legendItem) {
                    checkbox.checked = categoryVisibility[category];
                    if (categoryVisibility[category]) {
                        legendItem.classList.remove('disabled');
                    } else {
                        legendItem.classList.add('disabled');
                    }
                }
            });
        }

        // Load a single chunk with enhanced error handling
        async function loadChunk(url, index) {
            if (loadedChunks.has(index)) {
                console.log("Chunk " + index + " already loaded, skipping");
                return;
            }

            console.log("Attempting to load chunk " + (index + 1) + "/" + chunkUrls.length + " from: " + url);
            
            try {
                console.log("Fetching: " + url);
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error("HTTP " + response.status + ": " + response.statusText);
                }
                
                console.log("Response received for chunk " + index + ", status: " + response.status);
                const data = await response.json();
                console.log("Data parsed for chunk " + index + ", features: " + (data.features ? data.features.length : 0));
                
                if (data.features && data.features.length > 0) {
                    // Transform coordinates for each feature
                    data.features.forEach(function(feature) {
                        if (feature.geometry && feature.geometry.coordinates) {
                            if (feature.geometry.type === 'Polygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                            }
                        }
                    });

                    const geoJsonLayer = L.geoJSON(data, {
                        style: getStyle,
                        onEachFeature: function(feature, layer) {
                            const category = feature.properties.HILUCS_DESC || 'Unknown';
                            layer.bindTooltip("<b>HILUCS:</b> " + category, {
                                sticky: true,
                                direction: 'top'
                            });
                        }
                    });

                    geoJsonLayer.addTo(map);
                    chunkLayers.set(index, geoJsonLayer);
                    loadedChunks.add(index);
                    
                    console.log("â Chunk " + (index + 1) + " loaded successfully: " + data.features.length + " features");
                } else {
                    console.log("â ï¸ Chunk " + (index + 1) + " has no features");
                }
            } catch (error) {
                console.error("â Error loading chunk " + (index + 1) + ":", error);
                console.error("URL: " + url);
                console.error("Error details:", error.message);
            }
            
            updateChunkInfo();
        }

        // Load ALL chunks in batches of 10
        async function loadAllChunks() {
            if (isLoading) {
                console.log("Already loading, please wait...");
                return;
            }
            
            isLoading = true;
            showLoading();
            
            console.log("Starting to load ALL " + chunkUrls.length + " chunks in batches of 10...");
            
            const batchSize = 10;
            
            for (let i = 0; i < chunkUrls.length; i += batchSize) {
                const batchEnd = Math.min(i + batchSize, chunkUrls.length);
                const batch = [];
                
                // Create batch array
                for (let j = i; j < batchEnd; j++) {
                    if (!loadedChunks.has(j)) {
                        batch.push(j);
                    }
                }
                
                if (batch.length > 0) {
                    console.log("Loading batch " + (Math.floor(i/batchSize) + 1) + "/" + Math.ceil(chunkUrls.length/batchSize) + " - chunks " + (i + 1) + " to " + batchEnd);
                    
                    // Create promises for this batch
                    const promises = batch.map(function(index) {
                        return loadChunk(chunkUrls[index], index);
                    });
                    
                    // Wait for all chunks in this batch to complete
                    await Promise.allSettled(promises);
                    
                    console.log("Batch " + (Math.floor(i/batchSize) + 1) + " complete. Total loaded: " + loadedChunks.size + "/" + chunkUrls.length);
                    
                    // Small delay between batches to prevent overwhelming the browser
                    await new Promise(function(resolve) {
                        setTimeout(resolve, 500);
                    });
                }
            }
            
            isLoading = false;
            hideLoading();
            console.log("ð ALL CHUNKS LOADED! Total: " + loadedChunks.size + "/" + chunkUrls.length);
        }

        // Test if chunk URLs are accessible
        async function testChunkUrls() {
            console.log("Testing first few chunk URLs...");
            
            const testCount = Math.min(3, chunkUrls.length);
            for (let i = 0; i < testCount; i++) {
                const url = chunkUrls[i];
                try {
                    console.log("Testing URL: " + url);
                    const response = await fetch(url, { method: 'HEAD' });
                    console.log("URL " + i + ": " + response.status + " " + response.statusText);
                } catch (error) {
                    console.error("URL " + i + " failed:", error.message);
                }
            }
        }

        // Manual URL test
        function manualUrlTest() {
            const testUrl = "https://bhaskar-02.github.io/land-used-maps-2/land_use_chunk_0.geojson";
            console.log("Manual URL test:", testUrl);
            
            fetch(testUrl)
                .then(function(response) {
                    console.log("Manual test response:", response.status, response.statusText);
                    return response.text();
                })
                .then(function(text) {
                    console.log("Manual test response text length:", text.length);
                    console.log("First 200 characters:", text.substring(0, 200));
                    try {
                        JSON.parse(text);
                        console.log("â JSON is valid");
                    } catch (e) {
                        console.error("â JSON is invalid:", e.message);
                    }
                })
                .catch(function(error) {
                    console.error("Manual test error:", error);
                });
        }

        // Generate legend with FIXED toggle functionality
        function generateLegend() {
            const legendItems = document.getElementById('legend-items');
            const entries = Object.entries(colorMap);
            
            for (let i = 0; i < entries.length; i++) {
                const category = entries[i][0];
                const color = entries[i][1];
                
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.id = 'item-' + category;
                
                // Fixed click handler - now works on entire legend item
                item.addEventListener('click', function(event) {
                    toggleCategory(category, event);
                });
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'legend-checkbox';
                checkbox.id = 'checkbox-' + category;
                checkbox.checked = true;
                
                const colorDiv = document.createElement('div');
                colorDiv.className = 'legend-color';
                colorDiv.style.backgroundColor = color;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'legend-text';
                textDiv.textContent = category;
                
                item.appendChild(checkbox);
                item.appendChild(colorDiv);
                item.appendChild(textDiv);
                legendItems.appendChild(item);
            }
        }

        // Initialize everything
        console.log('Map initialized. Loading ALL chunks in batches of 10...');
        console.log('Total chunks available: ' + chunkUrls.length);
        
        generateLegend();
        updateChunkInfo();

        // Start the loading process
        manualUrlTest();

        setTimeout(function() {
            testChunkUrls().then(function() {
                console.log("Testing single chunk load...");
                return loadChunk(chunkUrls[0], 0);
            }).then(function() {
                if (loadedChunks.size > 0) {
                    console.log("Single chunk test successful, now loading ALL chunks...");
                    loadAllChunks(); // Load ALL chunks instead of just initial ones
                } else {
                    console.error("Single chunk test failed, but attempting to load all chunks anyway...");
                    loadAllChunks();
                }
            }).catch(function(error) {
                console.error("Error in initialization:", error);
                loadAllChunks();
            });
        }, 1000);
    </script>
</body>
</html>
